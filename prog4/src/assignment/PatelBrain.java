package assignment;

import java.security.InvalidParameterException;
import java.util.*;

/*
Rows Cleared: 0.6673732246946595
Holes Created: -0.7024683486787233
Ruggedness: -0.24728768280130548
*/

/**
 * A simple Brain implementation for JTetris; tries all possible places to put the
 * piece including rotations. Uses number of holes, ruggedness, and rows cleared to score the board
 */
public class PatelBrain implements Brain {
    private ArrayList<BoardState> options = new ArrayList<>();
    private Queue<Board.Action> actions = new LinkedList<>();


    private double ROWS_CLEARED;
    private double HOLES_CREATED;
    private double RUGGEDNESS;


    public Board.Action nextMove (Board currentBoard, double[] parameters){
        ROWS_CLEARED = parameters[0];
        HOLES_CREATED = parameters[1];
        RUGGEDNESS = parameters[2];

        //Uses the Queue to apply pre-computed actions
        if(actions.peek() != null){
            return actions.remove();
        }

        //Fills the our options array with versions of the new Board
        options = new ArrayList<>();
        enumerateOptions(currentBoard, options);

        if(options.size() == 0){
            return Board.Action.NOTHING;
        }

        //sets scores for every board in option and determines highestboard condition
        options.get(0).setScore(parameters);
        double maxScore = options.get(0).getScore();
        int bestIndex = 0;
        for(int i = 1; i < options.size(); i++){
            options.get(i).setScore(parameters);
            if(options.get(i).getScore() > maxScore){
                maxScore = options.get(i).getScore();
                bestIndex = i;
            }
        }

        actions = options.get(bestIndex).getActions();
        return actions.remove();
    }


    /**
     * Decide what the next move should be based on the state of the board.
     */
    public Board.Action nextMove(Board currentBoard) {
        //the parameters in Patel Brain are the same as the parameters generated by our gen-3 genetic algorithm
        //when tested with fair piece selection, they result in over a million lines cleared
        //without fair piece gen they typically clear more 1000 lines 90% of the time
        double[] parameters = {0.24435410383916226, -0.9413005953077075 , -0.23290397422610737};
        return nextMove(currentBoard, parameters);
    }

    /**
     * Tests all of the places we can put the current Piece.
     */
    private void enumerateOptions(Board currentBoard, List<BoardState> list){
        //options = new ArrayList<>();
        for(int i = 0; i < 4; i++){
            enumerateOptions(currentBoard, i, list);
        }
    }

    /**
     * Helper method that determines all posible moves for a certain rotation
     * @param currentBoard
     * @param rotation
     * @param list
     */
    private void enumerateOptions(Board currentBoard, int rotation, List<BoardState> list) {
        // We can always drop our current Piece
        Queue<Board.Action> acts = new LinkedList<>();
        Board.Action act;
        Board rotatedBoard;

        switch (rotation){
            case 0:
                act = Board.Action.DROP;

                rotatedBoard = currentBoard.testMove(Board.Action.NOTHING);
                list.add(new BoardState(rotatedBoard.testMove(act), acts));
                break;
            case 1:
                act = Board.Action.CLOCKWISE;

                acts.add(Board.Action.CLOCKWISE);

                rotatedBoard = currentBoard.testMove(act);
                list.add(new BoardState(rotatedBoard.testMove(Board.Action.DROP), acts));
                break;
            case 2:
                act = Board.Action.CLOCKWISE;

                acts.add(Board.Action.CLOCKWISE);
                acts.add(Board.Action.CLOCKWISE);

                rotatedBoard = currentBoard.testMove(act).testMove(act);
                list.add(new BoardState(rotatedBoard.testMove(Board.Action.DROP), acts));
                break;
            case 3:
                act = Board.Action.COUNTERCLOCKWISE;

                acts.add(Board.Action.COUNTERCLOCKWISE);

                rotatedBoard = currentBoard.testMove(act);
                list.add(new BoardState(rotatedBoard.testMove(Board.Action.DROP), acts));
                break;
            default:
                act = Board.Action.DROP;

                rotatedBoard = currentBoard.testMove(Board.Action.NOTHING);
                list.add(new BoardState(rotatedBoard.testMove(act), acts));
                break;
        }


        //Aadd all the places to the left we can DROP
        Board left = rotatedBoard.testMove(Board.Action.LEFT);
        Queue<Board.Action> leftActs = new LinkedList<>(acts);
        if(rotation == 0){
            act = Board.Action.LEFT;
        }
        while (left.getLastResult() == Board.Result.SUCCESS) {
            leftActs.add(Board.Action.LEFT);

            list.add(new BoardState(left.testMove(Board.Action.DROP), leftActs));

            left.move(Board.Action.LEFT);
        }

        //Same thing to the right
        Board right = rotatedBoard.testMove(Board.Action.RIGHT);
        Queue<Board.Action> rightActs = new LinkedList<>(acts);
        if(rotation == 0){
            act = Board.Action.RIGHT;
        }
        while (right.getLastResult() == Board.Result.SUCCESS) {
            rightActs.add(Board.Action.RIGHT);

            list.add(new BoardState(right.testMove(Board.Action.DROP), rightActs));

            right.move(Board.Action.RIGHT);
        }
    }

    //Static class allows us to observe the state of a created Board more directly
    protected static class BoardState{
        private Board option;
        private Queue<Board.Action> actions;

        private int rowsCleared;
        private int maxHeight;
        private int[] columnHeight;
        private int[] rowWidth;

        private int blocksCovered = 0;
        private int totalHeight = 0;
        private int[] minToMaxHeight;
        private int ruggedness;

        private double score = Integer.MIN_VALUE;

        public BoardState(Board option, Queue<Board.Action> actions){
            this.option = option.testMove(Board.Action.NOTHING);
            this.actions = new LinkedList<>(actions);
            this.actions.add(Board.Action.DROP);
            rowsCleared = option.getRowsCleared();
            maxHeight = option.getMaxHeight();
            columnHeight = new int[option.getWidth()];
            minToMaxHeight = new int[columnHeight.length];
            for(int x = 0; x < option.getWidth(); x++){
                columnHeight[x] = option.getColumnHeight(x);
                minToMaxHeight[x] = columnHeight[x];
                int filledBlocks = 0;
                for(int y = 0; y < option.getHeight(); y++){
                    if(getGrid(x, y)){
                        filledBlocks++;
                    }
                }
                blocksCovered += columnHeight[x] - filledBlocks;
                totalHeight += columnHeight[x];
                if(x != 0){
                    ruggedness += Math.abs(columnHeight[x] - columnHeight[x - 1]);
                }
            }
            Arrays.sort(minToMaxHeight);
            rowWidth = new int[option.getHeight()];
            for(int y = 0; y < option.getHeight(); y++){
                rowWidth[y] = option.getRowWidth(y);
            }
        }

        //Helper methods that return neccesary board information
        public Board getOption(){
            return option;
        }

        public Queue<Board.Action> getActions(){
            return new LinkedList<>(actions);
        }

        public Board.Action getFirstMove(){
            return actions.peek();
        }

        public int getRowsCleared(){
            return rowsCleared;
        }

        public int getMaxHeight(){
            return maxHeight;
        }

        public int getColumnHeight(int x){
            return columnHeight[x];
        }

        public int getRowWidth(int y){
            return rowWidth[y];
        }

        public boolean getGrid(int x, int y){
            return option.getGrid(x, y) != null;
        }

        public int getBlocksCovered(){
            return blocksCovered;
        }

        public int getTotalHeight(){
            return totalHeight;
        }

        public int getMinToMaxHeight(int x){
            return minToMaxHeight[x];
        }

        public int getRuggedness(){
            return ruggedness;
        }

        public void setScore(double[] parameters){
            //wiegths each parameter
            this.score = rowsCleared * parameters[0] + blocksCovered * parameters[1] + ruggedness * parameters[2];
        }

        public double getScore(){
            return score;
        }

        public boolean equals(Object other) {
            if(!(other instanceof BoardState)) return false;
            BoardState otherBoard = (BoardState) other;
            return option.equals(otherBoard.getOption());
        }
    }
}
